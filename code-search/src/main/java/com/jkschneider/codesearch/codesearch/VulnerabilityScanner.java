package com.jkschneider.codesearch.codesearch;

import org.objectweb.asm.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import static java.util.stream.Collectors.joining;

public class VulnerabilityScanner {
  private static Logger logger = LoggerFactory.getLogger(VulnerabilityScanner.class);
  private CallGraph callGraph = new CallGraph();

  public VulnerabilityScanner(InputStream jar) {
    buildCallGraph(jar);
  }

  public static void main(String[] args) throws IOException {
    try (InputStream is = new FileInputStream(new File("file-stats-0.0.1-SNAPSHOT.jar"))) {
      Collection<List<Call>> vulnerabilities = new VulnerabilityScanner(is)
        .vulnerabilities("org.zeroturnaround.zip.ZipUtil", "unpack", "..");

      for (List<Call> vulnerability : vulnerabilities) {
        System.out.println(vulnerability.stream().map(Call::toString).collect(joining(" <- ")));
      }
    }
  }

  public Collection<List<Call>> vulnerabilities(String className, String methodName, String... args) {
    return callGraph.callers(className, methodName, args);
  }

  private void buildCallGraph(InputStream is) {
    try (BufferedInputStream bis = new BufferedInputStream(is)) {
      analyzeJar(callGraph, bis);
    } catch (IOException e) {
      logger.warn("Unable to analyze jar ", e);
    }
  }

  private static void analyzeJar(CallGraph callGraph, InputStream is) throws IOException {
    ZipEntry ze;
    ZipInputStream zis = new ZipInputStream(is);
    while ((ze = zis.getNextEntry()) != null) {
      if (!ze.isDirectory() && ze.getName().endsWith(".class") && !ze.getName().startsWith("org/springframework")) {
        ClassVisitor visitor = new VulnerabilityClassVisitor(callGraph);
        new ClassReader(zis).accept(visitor, 0);
      } else if (ze.getName().endsWith(".jar")) {
        analyzeJar(callGraph, zis);
      }
    }
  }
}

class VulnerabilityClassVisitor extends ClassVisitor {
  private final CallGraph callGraph;

  public VulnerabilityClassVisitor(CallGraph callGraph) {
    super(Opcodes.ASM6);
    this.callGraph = callGraph;
  }

  private String className;
  private Call methodContext;

  @Override
  public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
    className = Type.getObjectType(name).getClassName();
    super.visit(version, access, name, signature, superName, interfaces);
  }

  @Override
  public void visitInnerClass(String name, String outerName, String innerName, int access) {
    String previousClass = className;
    if (outerName != null) {
      className = Type.getObjectType(outerName).getClassName() + "." + innerName;
    }
    super.visitInnerClass(name, outerName, innerName, access);
    className = previousClass;
  }

  @Override
  public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
    Type[] argumentTypes = Type.getArgumentTypes(descriptor);
    methodContext = new Call(className, name, Arrays.stream(argumentTypes).map(Type::getClassName).toArray(String[]::new));
    super.visitMethod(access, name, descriptor, signature, exceptions);
    return new VulnerableMethodVisitor();
  }

  class VulnerableMethodVisitor extends MethodVisitor {
    VulnerableMethodVisitor() {
      super(Opcodes.ASM6);
    }

    @Override
    public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {
      Type[] argumentTypes = Type.getArgumentTypes(descriptor);
      Call call = new Call(Type.getObjectType(owner).getClassName(), name, Arrays.stream(argumentTypes).map(Type::getClassName)
        .toArray(String[]::new));
      callGraph.addCall(methodContext, call);
      super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
    }
  }
}